<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-tw">
    <title>NatsuCamellia - Programming Language</title>
    <subtitle>When camellia blooms in summer.</subtitle>
    <link rel="self" type="application/atom+xml" href="https://natsucamellia.github.io/categories/programming-language/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://natsucamellia.github.io/"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-01-26T00:00:00+00:00</updated>
    <id>https://natsucamellia.github.io/categories/programming-language/atom.xml</id>
    <entry xml:lang="zh-tw">
        <title>Lambda Calculus 簡介</title>
        <published>2025-01-26T00:00:00+00:00</published>
        <updated>2025-01-26T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              NatsuCamellia
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://natsucamellia.github.io/lambda-calculus-intro/"/>
        <id>https://natsucamellia.github.io/lambda-calculus-intro/</id>
        
        <content type="html" xml:base="https://natsucamellia.github.io/lambda-calculus-intro/">&lt;h2 id=&quot;1-lambda-calculus&quot;&gt;1 Lambda Calculus&lt;&#x2F;h2&gt;
&lt;p&gt;Lambda calculus 是由數學家 Alonzo Church 在 1930 年代提出的一套數學邏輯規則，在程式語言領域中有重要的地位，被視為是程式語言的雛形。它對許多函數式程式語言造成很大的影響，如第一個函數式程式語言 Lisp、純函數式程式語言 Haskell 等，此外 Haskell 的標誌中的 λ 就代表 lambda calculus。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;natsucamellia.github.io&#x2F;lambda-calculus-intro&#x2F;.&#x2F;haskell-logo.svg&quot; alt=&quot;Haskell Logo&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;如果對於 Alan Turing 在相同年代提出的圖靈機有概念的話，lambda calculus 具有圖靈完備性，也就是說 lambda calculus 可以用來模擬圖靈機的運算。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;2-basics&quot;&gt;2 Basics&lt;&#x2F;h2&gt;
&lt;p&gt;我們首先定義 lambda calculus 的 syntax 以及 semantics。&lt;&#x2F;p&gt;
&lt;p&gt;Syntax（語法）指的是一門語言怎麼寫才是對的，semantics（語意）則是指語言的意義。在這裡，語言指的是 lambda calculus，程式語言領域中指的是程式語言本身，而在語言學中則是指自然語言。舉英文為例，句子的 syntax 可以是 S + V，其 semantics 為「S 做了動作 V」。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;2-1-syntax&quot;&gt;2.1 Syntax&lt;&#x2F;h3&gt;
&lt;p&gt;最簡單的 lambda calculus 包含了三種 &lt;strong&gt;terms&lt;&#x2F;strong&gt;：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;t ::= x     (variable)
&lt;&#x2F;span&gt;&lt;span&gt;      λx. t (abstraction)
&lt;&#x2F;span&gt;&lt;span&gt;      t t   (application)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;其中 &lt;code&gt;t&lt;&#x2F;code&gt; 代表的是 &lt;strong&gt;term&lt;&#x2F;strong&gt;，它可以是：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;由任何符號代表的 &lt;strong&gt;variable&lt;&#x2F;strong&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;完整的函式定義 &lt;strong&gt;abstraction&lt;&#x2F;strong&gt;，包括了 &lt;code&gt;λ&lt;&#x2F;code&gt; 與 &lt;code&gt;.&lt;&#x2F;code&gt; 之間一個參數 &lt;code&gt;x&lt;&#x2F;code&gt;，以及 &lt;code&gt;.&lt;&#x2F;code&gt; 之後代表函式本體的 term &lt;code&gt;t&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;將第二個 term 作為參數傳入第一個 term 的 &lt;strong&gt;application&lt;&#x2F;strong&gt;，類似於函式呼叫。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;t&lt;&#x2F;code&gt; 是一個 metavariable，它不存在於 syntax 中，它只用於指涉 term，也就是說在 application term 中的兩個 &lt;code&gt;t&lt;&#x2F;code&gt; 可以是兩個不同的 terms。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h3 id=&quot;2-2-semantics&quot;&gt;2.2 Semantics&lt;&#x2F;h3&gt;
&lt;p&gt;在最簡單的 lambda calculus 中沒有條件控制、迴圈等元素，計算方法只有將參數帶入函式而已，也就是將 abstraction 中的參數替換成右邊的 term：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;(λx. t1) t2 → [x ↦ t2]t1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;λx.&lt;&#x2F;code&gt; 後方會被視為一個整體，因此需要用括號限制 abstraction 的範圍。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;其中 &lt;code&gt;→&lt;&#x2F;code&gt; 代表左邊的 term 經過一步 evaluation 會變成右邊的 term，而 &lt;code&gt;[x ↦ t2]t1&lt;&#x2F;code&gt; 代表將 &lt;code&gt;t1&lt;&#x2F;code&gt; 中所有的 &lt;code&gt;x&lt;&#x2F;code&gt; 替換為 &lt;code&gt;t2&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;這裡說的「將 &lt;code&gt;t1&lt;&#x2F;code&gt; 中所有的 &lt;code&gt;x&lt;&#x2F;code&gt; 替換為 &lt;code&gt;t2&lt;&#x2F;code&gt;」其實是不準確的說法，應該要說「將 &lt;code&gt;t1&lt;&#x2F;code&gt; 中所有的 &lt;strong&gt;free variable&lt;&#x2F;strong&gt; &lt;code&gt;x&lt;&#x2F;code&gt; 替換為 &lt;code&gt;t2&lt;&#x2F;code&gt;」，因為我們一般預期的行為是&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;(λx. (λx. x) (x + 1)) n → (λx. x) (n + 1) → n + 1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;而非&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;(λx. (λx. x) (x + 1)) n → (λx. n) (n + 1) → n
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;所謂 free variable 簡單來說就是 &lt;code&gt;x&lt;&#x2F;code&gt; 不是任何 abstraction 的參數。在這個例子中，&lt;code&gt;t1 = (λx. x) (x + 1)&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(x + 1)&lt;&#x2F;code&gt; 的 &lt;code&gt;x&lt;&#x2F;code&gt; 是 &lt;code&gt;t1&lt;&#x2F;code&gt; 中的 &lt;strong&gt;free variable&lt;&#x2F;strong&gt;，因為這個 &lt;code&gt;x&lt;&#x2F;code&gt; 在 &lt;code&gt;t1&lt;&#x2F;code&gt; 中沒有對應的 &lt;code&gt;λx.&lt;&#x2F;code&gt;，所以根據 semantics 可以被替換成 &lt;code&gt;n&lt;&#x2F;code&gt;。&lt;&#x2F;li&gt;
&lt;li&gt;而 &lt;code&gt;(λx. x)&lt;&#x2F;code&gt; 中的 &lt;code&gt;x&lt;&#x2F;code&gt; 就不是 free variable，而是 &lt;strong&gt;bound variable&lt;&#x2F;strong&gt;，因為它和旁邊的 &lt;code&gt;λx.&lt;&#x2F;code&gt; 綁定（bound）。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;舉例而言，我們定義 identity function：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;id = λx. x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;從 syntax 的角度看，因為函式本體中的 &lt;code&gt;x&lt;&#x2F;code&gt;（第二個 &lt;code&gt;x&lt;&#x2F;code&gt;）是一個 variable，所以 &lt;code&gt;id&lt;&#x2F;code&gt; 是一個 abstraction。&lt;&#x2F;p&gt;
&lt;p&gt;接著我們透過 &lt;code&gt;id n&lt;&#x2F;code&gt; 觀察 semantics：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;id n
&lt;&#x2F;span&gt;&lt;span&gt;= (λx. x) n
&lt;&#x2F;span&gt;&lt;span&gt;→ [x ↦ n]x
&lt;&#x2F;span&gt;&lt;span&gt;= n
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;id&lt;&#x2F;code&gt; 確實是一個回傳參數本身的 identity function。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;3-programming&quot;&gt;3 Programming&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;3-1-multiple-arguments&quot;&gt;3.1 Multiple Arguments&lt;&#x2F;h3&gt;
&lt;p&gt;Abstraction terms 中，&lt;code&gt;λ&lt;&#x2F;code&gt; 後面只能定義一個參數，如果要讓一個函式可以接收多個參數，則需要透過 &lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;%E6%9F%AF%E9%87%8C%E5%8C%96&quot;&gt;currying&lt;&#x2F;a&gt; 讓一個函式回傳另一個函式來達到多個參數的效果。舉例而言，我們要讓一個函數接收兩個參數並回傳第一個參數，可以這樣定義：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;tru = λt. λf. t
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;展示使用的效果：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;tru x y
&lt;&#x2F;span&gt;&lt;span&gt;= (λt. λf. t) x y
&lt;&#x2F;span&gt;&lt;span&gt;→ (λf. x) y          &#x2F;&#x2F; t ↦ x
&lt;&#x2F;span&gt;&lt;span&gt;→ x                  &#x2F;&#x2F; f ↦ y
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;當 &lt;code&gt;tru&lt;&#x2F;code&gt; 接收參數 &lt;code&gt;x&lt;&#x2F;code&gt; 後就會得到另一個函式 &lt;code&gt;(λf. x)&lt;&#x2F;code&gt;，接著這個函式會負責接收第二個參數 &lt;code&gt;y&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;同樣的我們也可以定義回傳第二個參數的函式：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;fls = λt. λf. f
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;3-2-church-booleans&quot;&gt;3.2 Church Booleans&lt;&#x2F;h3&gt;
&lt;p&gt;以上介紹的兩個 term &lt;code&gt;tru&lt;&#x2F;code&gt; 和 &lt;code&gt;fls&lt;&#x2F;code&gt; 被稱為 &lt;strong&gt;Church booleans&lt;&#x2F;strong&gt;，相當於 lambda calculus 中的布林值。使用 &lt;code&gt;tru&lt;&#x2F;code&gt; 與 &lt;code&gt;fls&lt;&#x2F;code&gt; 命名的目的是避免和一般的布林值 &lt;code&gt;true&lt;&#x2F;code&gt; 與 &lt;code&gt;false&lt;&#x2F;code&gt; 搞混，Church booleans 實際上是 abstraction。&lt;&#x2F;p&gt;
&lt;p&gt;有了 &lt;code&gt;tru&lt;&#x2F;code&gt; 與 &lt;code&gt;fls&lt;&#x2F;code&gt; 後，我們可以將它們用於條件判斷，常見的 &lt;code&gt;if-then-else&lt;&#x2F;code&gt; 可以寫成接收三個參數的 term &lt;code&gt;test&lt;&#x2F;code&gt;：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;test = λb. λt. λf. b t f
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;test b t f&lt;&#x2F;code&gt; 的用法就相當於 &lt;code&gt;if b then t else f&lt;&#x2F;code&gt;，我們將 &lt;code&gt;tru&lt;&#x2F;code&gt; 或 &lt;code&gt;fls&lt;&#x2F;code&gt; 傳入作為第一個參數，然後傳入 then-branch 與 else-branch，如果 &lt;code&gt;b = tru&lt;&#x2F;code&gt;，那麼&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;test tru t f
&lt;&#x2F;span&gt;&lt;span&gt;→ tru t f
&lt;&#x2F;span&gt;&lt;span&gt;→ t
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;最後得到 &lt;code&gt;t&lt;&#x2F;code&gt;（&lt;code&gt;tru&lt;&#x2F;code&gt; 會回傳第一個參數！），反之若 &lt;code&gt;b = fls&lt;&#x2F;code&gt; 則會得到 &lt;code&gt;f&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;我們也可以定義邏輯運算：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;and = λb. λc. b c fls
&lt;&#x2F;span&gt;&lt;span&gt;or = λb. λc. b tru c
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;這裡的定義和 short-circuit 的概念有異曲同工之妙，在 short-circuit 中，如果 &lt;code&gt;b&lt;&#x2F;code&gt; 是 &lt;code&gt;false&lt;&#x2F;code&gt; 那麼 &lt;code&gt;b and c&lt;&#x2F;code&gt; 就不可能是 &lt;code&gt;true&lt;&#x2F;code&gt; 了，所以可以直接回傳 &lt;code&gt;false&lt;&#x2F;code&gt;，在上方的定義中，如果 &lt;code&gt;b&lt;&#x2F;code&gt; 是 &lt;code&gt;fls&lt;&#x2F;code&gt;，因為 &lt;code&gt;fls&lt;&#x2F;code&gt; 會選擇第二個參數，所以不管 &lt;code&gt;c&lt;&#x2F;code&gt; 為何 &lt;code&gt;b c fls&lt;&#x2F;code&gt; 都會直接回傳 &lt;code&gt;fls&lt;&#x2F;code&gt;。Short-circuit 這種提前回傳結果的概念在大多的現代程式語言中都有實作，因此需要注意 &lt;code&gt;and&lt;&#x2F;code&gt; 及 &lt;code&gt;or&lt;&#x2F;code&gt; 的第二個參數可能會被忽略，尤其當第二個參數是函式時，會導致函式沒有被執行。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;3-3-pairs&quot;&gt;3.3 Pairs&lt;&#x2F;h3&gt;
&lt;p&gt;在 lambda calculus 中如何表達資料結構呢？我們先看在函數式程式語言中最基本的資料結構 &lt;strong&gt;pair&lt;&#x2F;strong&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;在函數式程式語言中，tuple（元組）是一個簡單的資料結構，語法通常是括號中放多個元素並以 &lt;code&gt;,&lt;&#x2F;code&gt; 隔開，例如 &lt;code&gt;(1, 3, 5, 7)&lt;&#x2F;code&gt;、&lt;code&gt;(&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;)&lt;&#x2F;code&gt;，而 pair 就是元素數量為 2 的 tuple。&lt;&#x2F;p&gt;
&lt;p&gt;最常與 pair 搭配使用的函式是 &lt;code&gt;first&lt;&#x2F;code&gt; 與 &lt;code&gt;second&lt;&#x2F;code&gt;，分別可以取出第一個與第二個元素，利用 Church booleans 我們可以為 pair 定義以下 terms：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;pair = λf. λs. λb. b f s
&lt;&#x2F;span&gt;&lt;span&gt;first = λp. p tru
&lt;&#x2F;span&gt;&lt;span&gt;second = λp. p false
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;我們利用 &lt;code&gt;tru&lt;&#x2F;code&gt; 與 &lt;code&gt;fls&lt;&#x2F;code&gt; 能夠選擇第一個與第二個參數的特性，我們先把兩個元素放進 &lt;code&gt;pair&lt;&#x2F;code&gt; 中，要取出元素時再使用 &lt;code&gt;tru&lt;&#x2F;code&gt; 與 &lt;code&gt;fls&lt;&#x2F;code&gt; 取出想要的元素。例如我們可以將二維坐標 $(x, y)$ 儲存為：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;pos = pair x y
&lt;&#x2F;span&gt;&lt;span&gt;    = (λf. λs. λb. b f s) x y
&lt;&#x2F;span&gt;&lt;span&gt;    → (λb. b x y)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;現在只要傳入 &lt;code&gt;tru&lt;&#x2F;code&gt; 或 &lt;code&gt;fls&lt;&#x2F;code&gt; 給 &lt;code&gt;pos&lt;&#x2F;code&gt; 就可以取出 &lt;code&gt;x&lt;&#x2F;code&gt; 或 &lt;code&gt;y&lt;&#x2F;code&gt;，如果想要取出 &lt;code&gt;x&lt;&#x2F;code&gt; 座標就可以寫：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;first pos
&lt;&#x2F;span&gt;&lt;span&gt;= (λp. p tru) (λb. b x y)
&lt;&#x2F;span&gt;&lt;span&gt;→ (λb. b x y) tru
&lt;&#x2F;span&gt;&lt;span&gt;→ tru x y
&lt;&#x2F;span&gt;&lt;span&gt;→ x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;first&lt;&#x2F;code&gt; 就僅僅是將 &lt;code&gt;tru&lt;&#x2F;code&gt; 傳給參數 pair &lt;code&gt;p&lt;&#x2F;code&gt;，然後取得第一個元素而已，&lt;code&gt;second&lt;&#x2F;code&gt; 則是傳 &lt;code&gt;fls&lt;&#x2F;code&gt; 來取得第二個元素。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;3-4-church-numerals&quot;&gt;3.4 Church Numerals&lt;&#x2F;h3&gt;
&lt;p&gt;最後來看看如何在 lambda calculus 中表達自然數。這裡的概念和&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;zh-tw&#x2F;%E7%9A%AE%E4%BA%9A%E8%AF%BA%E5%85%AC%E7%90%86&quot;&gt;皮亞諾公設&lt;&#x2F;a&gt;的概念相似，皮亞諾公設中提到兩點：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;0 是自然數。&lt;&#x2F;li&gt;
&lt;li&gt;每一個確定的自然數 $a$，都有一個確定的後繼數（successor） $a&#x27;$ ，$a&#x27;$ 也是自然數。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;在 lambda calculus 中，&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Church_encoding#Church_numerals&quot;&gt;Church numerals&lt;&#x2F;a&gt; 的定義頗有皮亞諾公設的感覺，我們需要給定 &lt;strong&gt;0&lt;&#x2F;strong&gt; 是什麼以及 successor 是什麼意思，所以 Church numerals 的定義如下：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;c0 = λs. λz. z
&lt;&#x2F;span&gt;&lt;span&gt;c1 = λs. λz. s z
&lt;&#x2F;span&gt;&lt;span&gt;c2 = λs. λz. s (s z)
&lt;&#x2F;span&gt;&lt;span&gt;c3 = λs. λz. s (s (s z))
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;這裡變數名稱 &lt;code&gt;s&lt;&#x2F;code&gt; 代表 successor 而 &lt;code&gt;z&lt;&#x2F;code&gt; 代表 zero，&lt;code&gt;cn&lt;&#x2F;code&gt; 則是為了避免和一般的數字混淆。&lt;&#x2F;p&gt;
&lt;p&gt;可以看到每個 church numeral 只要給定了 successor 和 0 的定義，那麼它就是 well-defined。0 是 &lt;code&gt;z&lt;&#x2F;code&gt;、1 是 &lt;code&gt;z&lt;&#x2F;code&gt; 的下一個元素、2 則是 &lt;code&gt;z&lt;&#x2F;code&gt; 的下一個再下一個元素，依此類推。&lt;&#x2F;p&gt;
&lt;p&gt;這裡有個重要的觀察，如果換個角度想，&lt;code&gt;cn&lt;&#x2F;code&gt; 的作用其實就是接收一個函式 &lt;code&gt;s&lt;&#x2F;code&gt; 和一個元素 &lt;code&gt;z&lt;&#x2F;code&gt;，對 &lt;code&gt;z&lt;&#x2F;code&gt; 呼叫 &lt;code&gt;n&lt;&#x2F;code&gt; 次 &lt;code&gt;s&lt;&#x2F;code&gt;，也就是 $s^n(z)$。&lt;&#x2F;p&gt;
&lt;p&gt;接著介紹幾個常用於 Church numerals 的函式：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;succ = λn. λs. λz. s (n s z)
&lt;&#x2F;span&gt;&lt;span&gt;plus = λm. λn. λs. λz. m s (n s z)
&lt;&#x2F;span&gt;&lt;span&gt;times = λm. λn. m (plus n) c0
&lt;&#x2F;span&gt;&lt;span&gt;iszero = λn. n (λx. fls) tru
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;以上的定義中 &lt;code&gt;m&lt;&#x2F;code&gt; 與 &lt;code&gt;n&lt;&#x2F;code&gt; 都是 Church numerals。&lt;code&gt;succ&lt;&#x2F;code&gt; 概念上就是再多呼叫一次 &lt;code&gt;s&lt;&#x2F;code&gt;，&lt;code&gt;plus&lt;&#x2F;code&gt; 則是先呼叫 &lt;code&gt;n&lt;&#x2F;code&gt; 次再呼叫 &lt;code&gt;m&lt;&#x2F;code&gt; 次而達成 &lt;code&gt;m + n&lt;&#x2F;code&gt; 的效果，&lt;code&gt;times&lt;&#x2F;code&gt; 就是對 0 加上 &lt;code&gt;m&lt;&#x2F;code&gt; 次 &lt;code&gt;n&lt;&#x2F;code&gt;，&lt;code&gt;iszero&lt;&#x2F;code&gt; 使用一個總是回傳 &lt;code&gt;fls&lt;&#x2F;code&gt; 的函式，如果呼叫一次以上結果就會是 &lt;code&gt;fls&lt;&#x2F;code&gt;，如果 &lt;code&gt;n = c0&lt;&#x2F;code&gt; 則結果會是 &lt;code&gt;tru&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;最後介紹比較複雜的 &lt;code&gt;pred&lt;&#x2F;code&gt;（predecessor），取得前一個 Church numeral：&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;zz = pair c0 c0
&lt;&#x2F;span&gt;&lt;span&gt;ss = λp. pair (second p) (plus c1 (second p))
&lt;&#x2F;span&gt;&lt;span&gt;pred = λn. first (n ss zz)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;概念上是維護一個 pair 記錄上一個以及目前的 Church numeral &lt;code&gt;(last, this)&lt;&#x2F;code&gt;，&lt;code&gt;zz&lt;&#x2F;code&gt; 是一開始的狀態，&lt;code&gt;ss&lt;&#x2F;code&gt; 會把 $(c_n, c_m)$ 變成 $(c_m, c_{m+1})$。&lt;code&gt;pred&lt;&#x2F;code&gt; 對 &lt;code&gt;zz&lt;&#x2F;code&gt; 呼叫 &lt;code&gt;n &amp;gt; 0&lt;&#x2F;code&gt; 次 &lt;code&gt;ss&lt;&#x2F;code&gt; 後就會得到 $(c_{n-1}, c_n)$，然後呼叫 &lt;code&gt;first&lt;&#x2F;code&gt; 得到 $c_{n-1}$。&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;pred c3
&lt;&#x2F;span&gt;&lt;span&gt;→ first (c3 ss zz)                 
&lt;&#x2F;span&gt;&lt;span&gt;→ first (ss (ss (ss zz)))          
&lt;&#x2F;span&gt;&lt;span&gt;= first (ss (ss (ss (pair c0 c0))))
&lt;&#x2F;span&gt;&lt;span&gt;→ first (ss (ss (pair c0 c1)))     
&lt;&#x2F;span&gt;&lt;span&gt;→ first (ss (pair c1 c2))
&lt;&#x2F;span&gt;&lt;span&gt;→ first (pair c2 c3)
&lt;&#x2F;span&gt;&lt;span&gt;→ c2
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;4-lambda-abstractions&quot;&gt;4 Lambda Abstractions&lt;&#x2F;h2&gt;
&lt;p&gt;這裡列出本篇文章提到的所有 lambda abstractions。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;4-1-combinators&quot;&gt;4.1 Combinators&lt;&#x2F;h3&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;id = λx.x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;4-2-church-booleans&quot;&gt;4.2 Church Booleans&lt;&#x2F;h3&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;tru = λt. λf. t
&lt;&#x2F;span&gt;&lt;span&gt;fls = λt. λf. f
&lt;&#x2F;span&gt;&lt;span&gt;test = λb. λt. λf. b t f
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;4-3-church-numerals&quot;&gt;4.3 Church Numerals&lt;&#x2F;h3&gt;
&lt;pre style=&quot;background-color:#eff1f5;color:#4f5b66;&quot;&gt;&lt;code&gt;&lt;span&gt;c0 = λs. λz. z
&lt;&#x2F;span&gt;&lt;span&gt;c1 = λs. λz. s z
&lt;&#x2F;span&gt;&lt;span&gt;c2 = λs. λz. s (s z)
&lt;&#x2F;span&gt;&lt;span&gt;c3 = λs. λz. s (s (s z))
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;succ = λn. λs. λz. s (n s z)
&lt;&#x2F;span&gt;&lt;span&gt;plus = λm. λn. λz. m s (n s z)
&lt;&#x2F;span&gt;&lt;span&gt;times = λm. λn. m (plus n) c0
&lt;&#x2F;span&gt;&lt;span&gt;iszero = λn. n (λx. fls) tru
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;zz = pair c0 c0
&lt;&#x2F;span&gt;&lt;span&gt;ss = λp. pair (second p) (plus c1 (second p))
&lt;&#x2F;span&gt;&lt;span&gt;pred = λn. first (n ss zz)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;Types and Programming Languages, Benjamin C. Pierce&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;zh-tw&#x2F;%CE%9B%E6%BC%94%E7%AE%97&quot;&gt;λ演算 - 維基百科，自由的百科全書&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
        
    </entry>
</feed>
