<!DOCTYPE html>
<html lang="zh-Hant">
    <head>
        <title>
            
    XOR 消除法 | NatsuCamellia

        </title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta charset="utf-8">
        <link rel="stylesheet" href="https://natsucamellia.github.io/main.css">
        <!-- MathJax -->
        <script>
          MathJax = {
            tex: {
              inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
          };
        </script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <style>
          @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@100..900&family=Noto+Serif+TC:wght@200..900&display=swap');
        </style>
      </head>
  <body>
    <div class="container">
      <div class="content-container">
        
<header>
    <aside class="home-link">
      <a href="https:&#x2F;&#x2F;natsucamellia.github.io&#x2F;">← Home</a>
    </aside>
    <h1>
      XOR 消除法
    </h1>
    <p class="post-date">
      Published on 2022-10-23
    </p>
  </header>
  <article>
    <p>在解題的時候，有人使用最標準的思路來解題，我們稱之為 Best Practice；但也有人用較為特殊的技巧或想法來快速解題，雖然這可能不是題目最先設計的用意，但是它卻能有效率的解決問題，當中也有一些值得學習的小技巧。</p>
<blockquote>
<p>給予一個包含 n-1 個數字的陣列，範圍為 [1, n] ，所有數字都恰好出現一次，除了一個遺失的數字，請找出這個數字。</p>
</blockquote>
<p>當然，我們有很多直觀的解法來解決這個問題，但是讓我們來看看 XOR 能如何巧妙地解決這道題目吧。</p>
<h2 id="xor">XOR</h2>
<p>XOR 是一個用於位元的邏輯運算子，一般而言用 <code>^</code> 表示，如果兩個位元不同就回傳 <code>1</code> ，反之則回傳 <code>0</code>。</p>
<table><thead><tr><th>x</th><th>y</th><th>x ^ y</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td></tr>
</tbody></table>
<p>許多的程式語言會將<code>^</code>實作成位元運算子，讓 XOR 能對每個位元進行運算，例如：</p>
<pre data-lang="java" style="background-color:#eff1f5;color:#4f5b66;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#d08770;">0011 </span><span>^ </span><span style="color:#d08770;">1010 </span><span>= </span><span style="color:#d08770;">1001
</span></code></pre>
<p>因為：</p>
<pre data-lang="java" style="background-color:#eff1f5;color:#4f5b66;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#d08770;">0 </span><span>^ </span><span style="color:#d08770;">1 </span><span>= </span><span style="color:#d08770;">1
</span><span style="color:#d08770;">0 </span><span>^ </span><span style="color:#d08770;">0 </span><span>= </span><span style="color:#d08770;">0
</span><span style="color:#d08770;">1 </span><span>^ </span><span style="color:#d08770;">1 </span><span>= </span><span style="color:#d08770;">0
</span><span style="color:#d08770;">1 </span><span>^ </span><span style="color:#d08770;">0 </span><span>= </span><span style="color:#d08770;">1
</span></code></pre>
<p>因為有了這個特性，我們不只可以將 XOR 應用在布林值，我們甚至可以用在任何物件上。</p>
<h2 id="guan-yu-xor-de-te-xing">關於 XOR 的特性</h2>
<p>我們可以從先前的定義演繹出一些關於 XOR 的特性，我們先逐一了解這些特性，並接著使用它們來解決問題。</p>
<h3 id="dui-0-zuo-xor-x-0-x">對 0 做 XOR： <code>x ^ 0 = x</code></h3>
<table><thead><tr><th>x</th><th>y</th><th>x ^ y</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>1</td></tr>
</tbody></table>
<h3 id="dui-zi-ji-zuo-xor-x-x-0">對自己做 XOR： <code>x ^ x = 0</code></h3>
<p>這個很直觀，根據定義，兩個一樣的位元做 XOR 會回傳 <code>0</code>。</p>
<table><thead><tr><th>x</th><th>y</th><th>x ^ y</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>0</td></tr>
</tbody></table>
<h3 id="jiao-huan-lu-x-y-y-x">交換律： <code>x ^ y = y ^ x</code></h3>
<p>XOR 滿足交換律，也就是說我們可以任意交換 XOR 的順序，因為我們是要比較兩個位元是否相異，順序不重要。要證明交換律成立很簡單，我們只要檢查 <code>x ^ y</code> 和 <code>y ^ x</code> 的 Truth table 就可以了。</p>
<table><thead><tr><th>x</th><th>y</th><th>x ^ y</th><th>y ^ x</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td><td>0</td></tr>
</tbody></table>
<h2 id="xor-yun-suan-de-xian-xiang">XOR 運算的現象</h2>
<p>結合以上幾個特性，我們可以得到一個非常有用的技巧：</p>
<blockquote>
<p>XOR 消除法：如果我們有一連串的 XOR 運算 <code>a ^ b ^ c ^ …</code> ，我們可以消除每一對重複的數字，而不影響運算結果。</p>
</blockquote>
<p>消除法的中心思想是：我們先運用交換律交換運算順序，再利用 <code>x ^ x = 0</code> 的性質來消除每一對重複的數字。</p>
<p>讓我們來看看一個例子：</p>
<pre data-lang="java" style="background-color:#eff1f5;color:#4f5b66;" class="language-java "><code class="language-java" data-lang="java"><span>  a ^ c ^ d ^ b ^ d ^ c ^ a
</span><span>= a ^ a ^ c ^ c ^ d ^ d ^ b  </span><span style="color:#a7adba;">// 交換律
</span><span>= </span><span style="color:#d08770;">0 </span><span>^ </span><span style="color:#d08770;">0 </span><span>^ </span><span style="color:#d08770;">0 </span><span>^ b              </span><span style="color:#a7adba;">// x ^ x = 0
</span><span>= b                          </span><span style="color:#a7adba;">// x ^ 0 = x
</span></code></pre>
<p>並且因為 <code>^</code> 是位元運算子，這個技巧不管 <code>a</code> , <code>b</code> , <code>c</code> , <code>d</code> 是什麼資料型態都可以使用。</p>
<h2 id="ying-yong-yi-jiao-huan-liang-ge-shu-zi">應用一：交換兩個數字</h2>
<p>在解決找出遺失數字的問題前，我們先來看看這個問題</p>
<blockquote>
<p>交換兩個數字，而不使用額外的變數。</p>
</blockquote>
<p>這看起來有點棘手，但是我們可以透過 XOR 輕鬆完成：</p>
<pre data-lang="java" style="background-color:#eff1f5;color:#4f5b66;" class="language-java "><code class="language-java" data-lang="java"><span>x ^= y
</span><span>y ^= x
</span><span>x ^= y
</span></code></pre>
<p>看起來有點神奇對吧，但是它是真的可以辦到交換兩數的，我們透過拆解每個步驟，註解中表示每一行執行完之後 <code>(x, y)</code> 的值，來看看它到底是如何完成的：</p>
<pre data-lang="java" style="background-color:#eff1f5;color:#4f5b66;" class="language-java "><code class="language-java" data-lang="java"><span>x ^= y </span><span style="color:#a7adba;">// (x ^ y, y)
</span><span>y ^= x </span><span style="color:#a7adba;">// (x ^ y, y ^ x ^ y) =&gt; (x ^ y, x)
</span><span>x ^= y </span><span style="color:#a7adba;">// (x ^ y ^ x, x) =&gt; (y, x)
</span></code></pre>
<p>我們可以發現，這其實只是使用我們先前導出的一些特性而已。</p>
<h2 id="ying-yong-er-zhao-chu-yi-shi-de-shu-zi">應用二：找出遺失的數字</h2>
<p>我們終於要來解決一開始的題目了，我們重新來看看題目：</p>
<blockquote>
<p>給予一個包含 n-1 個數字的陣列，範圍為 [1, n] ，所有數字都恰好出現一次，除了一個遺失的數字，請找出這個數字。</p>
</blockquote>
<p>當然，我們有很多解法來解決這個問題，但是讓我們用學到的新玩具 XOR 來解決這道題目。</p>
<p>我們知道 XOR 可以消除重複出現的元素，但是如果我們只是對每個元素 XOR ，我們就沒辦法運用消除的這個特性，因為每個元素只出現最多一次。</p>
<pre data-lang="java" style="background-color:#eff1f5;color:#4f5b66;" class="language-java "><code class="language-java" data-lang="java"><span>a[</span><span style="color:#d08770;">0</span><span>] ^ a[</span><span style="color:#d08770;">1</span><span>] ^ ... ^ a[n-</span><span style="color:#d08770;">2</span><span>]
</span></code></pre>
<p>請注意因為我們只有 <code>n-1</code> 個元素，所以最後一個索引值是 <code>n-2</code></p>
<p>那該怎麼辦呢，如同前總統馬英九所說的：</p>
<blockquote>
<p>一個便當吃不夠，你可以吃兩個。</p>
</blockquote>
<p>所以呢？</p>
<blockquote>
<p>一個元素 XOR 不夠，你可以 XOR 兩個。</p>
</blockquote>
<p>讓我們也把 1 到 n XOR 進去：</p>
<pre data-lang="java" style="background-color:#eff1f5;color:#4f5b66;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#d08770;">1 </span><span>^ </span><span style="color:#d08770;">2 </span><span>^ ... ^ n ^ a[</span><span style="color:#d08770;">0</span><span>] ^ a[</span><span style="color:#d08770;">1</span><span>] ^ ... ^ a[n-</span><span style="color:#d08770;">2</span><span>]
</span></code></pre>
<p>我們會得到一個這樣的 XOR 序列：</p>
<ul>
<li>給定的數字都會出現兩次：
<ul>
<li>其中一次在我們 XOR 進去的 1 到 n 之中。</li>
<li>另一次在給定的陣列中。</li>
</ul>
</li>
<li>遺失的數字只會出現一次：
<ul>
<li>我們 XOR 進去的 1 到 n 之中。</li>
</ul>
</li>
</ul>
<p>如果我們把這些全部 XOR 起來，給定的數字會因為出現兩次而被消除，得益於 XOR 消除法；而遺失的數字只出現一次，不會被消除。也就是說結果會剩下遺失的數字，也就是題目所求的答案。</p>
<p>用程式碼表現，大概會像這個樣子：</p>
<pre data-lang="java" style="background-color:#eff1f5;color:#4f5b66;" class="language-java "><code class="language-java" data-lang="java"><span style="color:#b48ead;">public int </span><span style="color:#bf616a;">findMissing</span><span>(</span><span style="color:#b48ead;">int[]</span><span> array, </span><span style="color:#b48ead;">int</span><span> n) {
</span><span>    </span><span style="color:#b48ead;">int</span><span> missing = </span><span style="color:#d08770;">0</span><span>;
</span><span>
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">1</span><span>; i &lt;= n; i++) {
</span><span>        missing ^= i;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i : array) {
</span><span>        missing ^= i;
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#b48ead;">return</span><span> missing;
</span><span>}
</span></code></pre>
<p>觀察這段程式碼，可能讓人不懂背後的演算法原理，但是我們知道了 XOR 消除法後，我們會發現其實是非常簡單的概念。但是我不推薦把這段程式碼拿給別人看，因為他會需要了解這個技巧才能知道這段程式碼的想法。</p>
<h3 id="tui-guang-zhi-suo-you-zi-liao-xing-tai">推廣至所有資料型態</h3>
<p>我們也可以運用這個演算法在各種資料型態上，尋找缺失的元素，只要符合以下條件：</p>
<ol>
<li>給定出現過的元素</li>
<li>給定所有元素</li>
</ol>
<p>我們就能套用在任何一種資料型態上，例如：</p>
<ul>
<li>我們有所有 <code>Person</code> 的集合，就可以找出缺失的 <code>Person</code> 。</li>
<li>我們有所有節點的集合，就可以找出缺失的節點。</li>
<li>就算不是連續整數，只要我們有所有整數的集合，和出現過的整數，我們就能找到缺失的整數。</li>
</ul>
<h2 id="lian-xi-zhao-chu-zhong-fu-de-shu-zi">練習：找出重複的數字</h2>
<blockquote>
<p>給予一個包含 n+1 個數字的陣列，範圍為 [1, n] ，所有數字都恰好出現一次，除了一個重複的數字出現了兩次，請找出這個數字。</p>
</blockquote>

  </article>

      </div>
    </div>
  </body>
</html>